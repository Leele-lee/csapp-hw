# 12-23

## where wrong?

In the original version of the server, the `check_clients` function tries to read a full line (ending with `\n`) using `Rio_readlineb`. This **blocks** if the client sends only part of a line and doesn’t end it with `\n`. This allows a malicious client to deny service to others by keeping the server stuck waiting.

## `check_clients`

```c
char buf[FD_SETSIZE][MAXLINE];   // Per-client buffer
int buf_len[FD_SETSIZE];         // Current length of buffer
```

Client connects:

1. Types "hello" and waits
2. Server reads "hello" (no \n) → buffer updated, but no echo
3. Client types "\n"
4. Now server finds full line in buffer → echoes it
5. Any remaining data is kept for next round

And in check_clients():

- Use recv(connfd, ...) or read() to non-blockingly get available bytes
- Append to the per-client buffer
- Check if any full line (\n) exists — if yes, echo that line

```c
for all the satisfied connfd
    first decrement nready
    if loop for n = readn > 0 first check now buffer[connfd] length > max_len?,
     if yes, stderr and close ... 
     if not, add to respond buffer, and add the read bytes to buf_len according return num
     check whether the last element is \n or not(using memchr);
      if \n, writen to connfd, clear correspond buf(using memmove, be noticed the difference between memmove and memcpy), 
      reduce correspond buf_len;
      if not, do nothing
    for readn < 0,just act like before(close...)
```
